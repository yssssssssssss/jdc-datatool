# 图表类型支持与扩展指南

## 当前支持的图表类型

### 1. 核心图表类型（7种）

JDC数据分析系统当前支持以下7种核心图表类型，通过`VisualizationGenerator`类实现：

| 图表类型 | 方法名 | 用途 | 参数要求 |
|---------|--------|------|----------|
| **直方图** | `generate_histogram()` | 显示数值分布 | 1个数值列 |
| **散点图** | `generate_scatter_plot()` | 分析两变量相关性 | 2个数值列 |
| **折线图** | `generate_line_chart()` | 显示趋势变化 | 1个X轴列 + 1个Y轴列 |
| **柱状图** | `generate_bar_chart()` | 分类数据比较 | 1个分类列（可选数值列） |
| **饼图** | `generate_pie_chart()` | 显示占比关系 | 1个分类列 |
| **热力图** | `generate_heatmap()` | 相关性矩阵 | 多个数值列 |
| **箱线图** | `generate_box_plot()` | 分布和异常值 | 1个数值列 |

### 2. 扩展图表类型（4种）

系统还支持以下扩展图表类型，通过现有方法的组合实现：

| 图表类型 | 实现方式 | 说明 |
|---------|----------|------|
| **小提琴图** | 使用`generate_box_plot()` | 用箱线图作为替代 |
| **面积图** | 使用`generate_line_chart()` | 用折线图作为替代 |
| **雷达图** | 使用`generate_heatmap()` | 生成相关性分析热力图 |
| **交互式图表** | `generate_interactive_plot()` | 基于Plotly的交互式版本 |

### 3. 图表生成技术栈

- **主要绘图库**: Matplotlib + Seaborn
- **交互式图表**: Plotly Express + Plotly Graph Objects
- **输出格式**: Base64编码的PNG图片
- **中文支持**: 配置SimHei、Microsoft YaHei字体

## 图表可视化实现类

### 核心类：`VisualizationGenerator`

**位置**: `backend/visualization.py`

**职责**:
- 负责所有图表的具体绘制逻辑
- 处理数据预处理和格式转换
- 统一图表样式和配色方案
- 将图表转换为Base64格式供前端显示

**核心方法结构**:
```python
class VisualizationGenerator:
    def __init__(self):
        # 设置中文字体和样式
        
    def generate_histogram(self, data: pd.Series, title: str) -> str:
        # 生成直方图，返回Base64字符串
        
    def generate_scatter_plot(self, x_data: pd.Series, y_data: pd.Series, title: str) -> str:
        # 生成散点图，返回Base64字符串
        
    # ... 其他图表生成方法
    
    def _fig_to_base64(self, fig) -> str:
        # 将matplotlib图表转换为Base64字符串
        
    def get_chart_suggestions(self, data: pd.DataFrame) -> List[Dict]:
        # 根据数据类型推荐图表
```

## 图表生成调用流程

### 1. 调用路径

```
用户请求 → ChartAgent → VisualizationGenerator → 具体图表方法 → Base64图片
```

### 2. 详细调用流程

#### 方式一：通过ChartAgent（智能推断）
```python
# chart_agent.py
def _generate_chart_from_config(self, df: pd.DataFrame, config: Dict):
    chart_config = {
        'chart_type': chart_type,
        'columns': valid_columns,
        'title': title
    }
    return self.chart_generator.generate_chart(df, chart_config)  # 注意：这个方法不存在！
```

**问题发现**: `ChartAgent`调用了`self.chart_generator.generate_chart()`方法，但`VisualizationGenerator`类中并没有这个方法！

#### 方式二：通过Flask API（直接调用）
```python
# app.py - /api/generate_chart路由
viz_generator = VisualizationGenerator()

if chart_type == 'histogram':
    chart_base64 = viz_generator.generate_histogram(df[columns[0]], title)
elif chart_type == 'scatter':
    chart_base64 = viz_generator.generate_scatter_plot(df[columns[0]], df[columns[1]], title)
elif chart_type == 'line':
    chart_base64 = viz_generator.generate_line_chart(df, columns[0], columns[1], title)
# ... 其他图表类型
```

### 3. 绘图函数详解

所有图表都使用**Matplotlib**作为底层绘图引擎：

```python
def generate_histogram(self, data: pd.Series, title: str = "直方图") -> str:
    fig, ax = plt.subplots(figsize=(10, 6))  # 创建画布
    ax.hist(data.dropna(), bins=30, alpha=0.7, color='#6c757d', edgecolor='black')  # 绘制直方图
    ax.set_title(title, fontsize=14, fontweight='bold')  # 设置标题
    ax.set_xlabel('数值', fontsize=12)  # 设置X轴标签
    ax.set_ylabel('频次', fontsize=12)  # 设置Y轴标签
    ax.grid(True, alpha=0.3)  # 添加网格
    
    return self._fig_to_base64(fig)  # 转换为Base64
```

**通用绘图流程**:
1. 创建matplotlib画布 (`plt.subplots()`)
2. 绘制具体图表 (`ax.hist()`, `ax.scatter()`, `ax.plot()`等)
3. 设置标题、轴标签、网格等样式
4. 转换为Base64字符串 (`_fig_to_base64()`)
5. 关闭图表释放内存 (`plt.close()`)

## 如何扩展更多图表类型

### 1. 在VisualizationGenerator中添加新方法

**步骤1**: 在`backend/visualization.py`中添加新的图表生成方法

```python
def generate_violin_plot(self, data: pd.DataFrame, column: str, title: str = "小提琴图") -> str:
    """生成小提琴图"""
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # 使用seaborn绘制小提琴图
    sns.violinplot(data=data, y=column, ax=ax, color='#6c757d')
    
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_ylabel(column, fontsize=12)
    ax.grid(True, alpha=0.3)
    plt.tight_layout()
    
    return self._fig_to_base64(fig)

def generate_area_chart(self, data: pd.DataFrame, x_col: str, y_col: str, title: str = "面积图") -> str:
    """生成面积图"""
    fig, ax = plt.subplots(figsize=(12, 6))
    
    ax.fill_between(data[x_col], data[y_col], alpha=0.7, color='#6c757d')
    ax.plot(data[x_col], data[y_col], color='#2c2c2c', linewidth=2)
    
    ax.set_title(title, fontsize=14, fontweight='bold')
    ax.set_xlabel(x_col, fontsize=12)
    ax.set_ylabel(y_col, fontsize=12)
    ax.grid(True, alpha=0.3)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    return self._fig_to_base64(fig)

def generate_radar_chart(self, data: pd.DataFrame, columns: List[str], title: str = "雷达图") -> str:
    """生成雷达图"""
    import numpy as np
    
    # 计算角度
    angles = np.linspace(0, 2 * np.pi, len(columns), endpoint=False).tolist()
    angles += angles[:1]  # 闭合图形
    
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(projection='polar'))
    
    # 绘制每一行数据
    for idx, row in data.iterrows():
        values = row[columns].tolist()
        values += values[:1]  # 闭合图形
        
        ax.plot(angles, values, 'o-', linewidth=2, label=f'样本{idx}')
        ax.fill(angles, values, alpha=0.25)
    
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(columns)
    ax.set_title(title, fontsize=14, fontweight='bold', pad=20)
    ax.legend()
    
    return self._fig_to_base64(fig)
```

### 2. 修复ChartAgent调用问题

**问题**: `ChartAgent`调用了不存在的`generate_chart()`方法

**解决方案**: 在`VisualizationGenerator`中添加统一的调度方法

```python
def generate_chart(self, df: pd.DataFrame, config: Dict) -> Optional[str]:
    """统一的图表生成入口"""
    chart_type = config.get('chart_type')
    columns = config.get('columns', [])
    title = config.get('title', '数据图表')
    
    try:
        if chart_type == 'histogram' and len(columns) >= 1:
            return self.generate_histogram(df[columns[0]], title)
        elif chart_type == 'scatter' and len(columns) >= 2:
            return self.generate_scatter_plot(df[columns[0]], df[columns[1]], title)
        elif chart_type == 'line' and len(columns) >= 2:
            return self.generate_line_chart(df, columns[0], columns[1], title)
        elif chart_type == 'bar' and len(columns) >= 1:
            # 处理分类数据的分组统计
            if df[columns[0]].dtype == 'object':
                if len(columns) >= 2:
                    grouped_data = df.groupby(columns[0])[columns[1]].mean()
                else:
                    grouped_data = df[columns[0]].value_counts()
                return self.generate_bar_chart(grouped_data, title)
            else:
                return self.generate_bar_chart(df[columns[0]], title)
        elif chart_type == 'pie' and len(columns) >= 1:
            return self.generate_pie_chart(df[columns[0]], title)
        elif chart_type == 'heatmap':
            numeric_df = df.select_dtypes(include=['number'])
            if not numeric_df.empty:
                return self.generate_heatmap(numeric_df, title)
        elif chart_type == 'box' and len(columns) >= 1:
            return self.generate_box_plot(df, columns[0], title)
        elif chart_type == 'violin' and len(columns) >= 1:
            return self.generate_violin_plot(df, columns[0], title)
        elif chart_type == 'area' and len(columns) >= 2:
            return self.generate_area_chart(df, columns[0], columns[1], title)
        elif chart_type == 'radar' and len(columns) >= 3:
            return self.generate_radar_chart(df, columns, title)
        else:
            return None
            
    except Exception as e:
        logging.error(f"图表生成失败: {e}")
        return None
```

### 3. 更新ChartAgent的关键词映射

在`backend/chart_agent.py`中更新关键词映射：

```python
chart_keywords = {
    'histogram': ['分布', '直方图', 'histogram', '频率'],
    'scatter': ['散点', '相关', 'scatter', '关系'],
    'line': ['折线', '趋势', 'line', '时间', '变化'],
    'bar': ['柱状', '条形', 'bar', '比较', '排名', '最高', '最低', 'top'],
    'pie': ['饼图', 'pie', '占比', '比例', '份额'],
    'box': ['箱线', 'box', '异常', '分位'],
    'heatmap': ['热力', 'heatmap', '相关性矩阵'],
    'violin': ['小提琴', 'violin', '密度分布'],  # 新增
    'area': ['面积', 'area', '累积', '填充'],     # 新增
    'radar': ['雷达', 'radar', '多维', '综合']    # 新增
}
```

### 4. 更新Flask API路由

在`backend/app.py`的`/api/generate_chart`路由中添加新图表类型的处理：

```python
elif chart_type == 'violin' and len(columns) >= 1:
    chart_base64 = viz_generator.generate_violin_plot(df, columns[0], title)
elif chart_type == 'area' and len(columns) >= 2:
    chart_base64 = viz_generator.generate_area_chart(df, columns[0], columns[1], title)
elif chart_type == 'radar' and len(columns) >= 3:
    chart_base64 = viz_generator.generate_radar_chart(df, columns, title)
```

## 如何增加新的可视化工具

### 1. 集成新的绘图库

**示例：集成Bokeh**

```python
# 在visualization.py中添加
from bokeh.plotting import figure, save
from bokeh.io import export_png
from bokeh.models import HoverTool

def generate_bokeh_scatter(self, x_data: pd.Series, y_data: pd.Series, title: str = "交互散点图") -> str:
    """使用Bokeh生成交互式散点图"""
    p = figure(title=title, x_axis_label=x_data.name, y_axis_label=y_data.name,
               width=800, height=600)
    
    # 添加散点
    p.circle(x_data, y_data, size=8, alpha=0.6)
    
    # 添加悬停工具
    hover = HoverTool(tooltips=[
        (x_data.name, '@x'),
        (y_data.name, '@y')
    ])
    p.add_tools(hover)
    
    # 导出为PNG并转换为Base64
    # 注意：需要安装selenium和geckodriver
    export_png(p, filename="temp_bokeh.png")
    
    with open("temp_bokeh.png", "rb") as f:
        image_base64 = base64.b64encode(f.read()).decode('utf-8')
    
    os.remove("temp_bokeh.png")  # 清理临时文件
    
    return f"data:image/png;base64,{image_base64}"
```

### 2. 集成专业统计图表库

**示例：集成Plotly的高级图表**

```python
import plotly.graph_objects as go
from plotly.subplots import make_subplots

def generate_candlestick_chart(self, data: pd.DataFrame, title: str = "K线图") -> str:
    """生成K线图（需要开高低收四列数据）"""
    fig = go.Figure(data=go.Candlestick(
        x=data.index,
        open=data['开盘价'],
        high=data['最高价'],
        low=data['最低价'],
        close=data['收盘价']
    ))
    
    fig.update_layout(title=title, xaxis_title='时间', yaxis_title='价格')
    
    # 转换为静态图片
    img_bytes = fig.to_image(format="png", width=1000, height=600)
    image_base64 = base64.b64encode(img_bytes).decode('utf-8')
    
    return f"data:image/png;base64,{image_base64}"

def generate_3d_scatter(self, data: pd.DataFrame, x_col: str, y_col: str, z_col: str, title: str = "3D散点图") -> str:
    """生成3D散点图"""
    fig = go.Figure(data=go.Scatter3d(
        x=data[x_col],
        y=data[y_col],
        z=data[z_col],
        mode='markers',
        marker=dict(
            size=5,
            color=data[z_col],
            colorscale='Viridis',
            showscale=True
        )
    ))
    
    fig.update_layout(
        title=title,
        scene=dict(
            xaxis_title=x_col,
            yaxis_title=y_col,
            zaxis_title=z_col
        )
    )
    
    img_bytes = fig.to_image(format="png", width=1000, height=600)
    image_base64 = base64.b64encode(img_bytes).decode('utf-8')
    
    return f"data:image/png;base64,{image_base64}"
```

### 3. 集成机器学习可视化

**示例：集成scikit-learn的可视化工具**

```python
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import matplotlib.pyplot as plt

def generate_pca_plot(self, data: pd.DataFrame, title: str = "PCA降维图") -> str:
    """生成PCA降维可视化"""
    # 只使用数值列
    numeric_data = data.select_dtypes(include=[np.number])
    
    if numeric_data.shape[1] < 2:
        return None
    
    # 执行PCA
    pca = PCA(n_components=2)
    pca_result = pca.fit_transform(numeric_data.fillna(0))
    
    # 绘制结果
    fig, ax = plt.subplots(figsize=(10, 8))
    scatter = ax.scatter(pca_result[:, 0], pca_result[:, 1], alpha=0.6, c=range(len(pca_result)), cmap='viridis')
    
    ax.set_title(f"{title}\n解释方差比: PC1={pca.explained_variance_ratio_[0]:.2%}, PC2={pca.explained_variance_ratio_[1]:.2%}")
    ax.set_xlabel(f'第一主成分 ({pca.explained_variance_ratio_[0]:.2%})')
    ax.set_ylabel(f'第二主成分 ({pca.explained_variance_ratio_[1]:.2%})')
    ax.grid(True, alpha=0.3)
    
    plt.colorbar(scatter)
    plt.tight_layout()
    
    return self._fig_to_base64(fig)

def generate_tsne_plot(self, data: pd.DataFrame, title: str = "t-SNE降维图") -> str:
    """生成t-SNE降维可视化"""
    numeric_data = data.select_dtypes(include=[np.number])
    
    if numeric_data.shape[1] < 2 or len(numeric_data) < 4:
        return None
    
    # 执行t-SNE
    tsne = TSNE(n_components=2, random_state=42, perplexity=min(30, len(numeric_data)-1))
    tsne_result = tsne.fit_transform(numeric_data.fillna(0))
    
    # 绘制结果
    fig, ax = plt.subplots(figsize=(10, 8))
    scatter = ax.scatter(tsne_result[:, 0], tsne_result[:, 1], alpha=0.6, c=range(len(tsne_result)), cmap='viridis')
    
    ax.set_title(title)
    ax.set_xlabel('t-SNE 1')
    ax.set_ylabel('t-SNE 2')
    ax.grid(True, alpha=0.3)
    
    plt.colorbar(scatter)
    plt.tight_layout()
    
    return self._fig_to_base64(fig)
```

## 扩展建议和最佳实践

### 1. 代码组织建议

```python
# 建议的文件结构
backend/
├── visualization/
│   ├── __init__.py
│   ├── base.py              # 基础可视化类
│   ├── statistical.py       # 统计图表（直方图、箱线图等）
│   ├── relational.py        # 关系图表（散点图、热力图等）
│   ├── categorical.py       # 分类图表（柱状图、饼图等）
│   ├── time_series.py       # 时间序列图表
│   ├── advanced.py          # 高级图表（3D、机器学习等）
│   └── interactive.py       # 交互式图表
└── visualization.py         # 主入口文件
```

### 2. 扩展新图表的标准流程

1. **在VisualizationGenerator中添加生成方法**
2. **更新统一调度方法generate_chart()**
3. **在ChartAgent中添加关键词映射**
4. **在Flask API中添加路由处理**
5. **在LLM提示词中添加图表类型说明**
6. **编写单元测试验证功能**

### 3. 性能优化建议

- **图片缓存**: 对相同数据和配置的图表进行缓存
- **异步生成**: 对复杂图表使用异步生成
- **内存管理**: 及时关闭matplotlib图表释放内存
- **格式优化**: 根据需要选择PNG/SVG/WebP格式

### 4. 错误处理和日志

```python
import logging

def generate_chart_with_fallback(self, df: pd.DataFrame, config: Dict) -> Optional[str]:
    """带降级策略的图表生成"""
    try:
        return self.generate_chart(df, config)
    except Exception as e:
        logging.error(f"图表生成失败: {e}, 配置: {config}")
        
        # 降级策略：生成简单的柱状图
        try:
            numeric_cols = df.select_dtypes(include=[np.number]).columns
            if len(numeric_cols) > 0:
                return self.generate_histogram(df[numeric_cols[0]], "数据分布图（降级）")
        except Exception as fallback_error:
            logging.error(f"降级图表生成也失败: {fallback_error}")
            return None
```

通过以上扩展方案，可以轻松地为JDC数据分析系统添加更多图表类型和可视化工具，满足不同的数据分析需求。
